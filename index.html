<script>
const SPECS = { n: 319.7, s: 99.4, st: 163, jt: 100 };
let hits = 0, rushCount = 0, currentRot = 0, totalRot = 0, totalBall = 0, currentRushHits = 0, maxHamari = 0;
let mode = '通常', rRem = 0, isAuto = false, autoSpeed = 'slow', isAnim = false;
let lcdCount = 0, optKokuchi = false, originalSpeedSetting = 'slow';
let reservedStock = [], activeJob = null;
let slumpData = [0], slumpLabels = ["0"], historyData = [], historyLabels = [];
let sChart, hChart;

const TRUST_MAP_N = { 
    "白レバ": 0.90, "赤レバ": 0.965, "虹レバ": 1.0, 
    "赤保留": 0.90, "緑保留": 0.11, "青保留": 0.03, "点滅保留": 0.01,
    "次回予告": 0.65, "レイ背景": 0.85, "金系": 0.50, "渚カヲル": 1.0 
};
const TRUST_MAP_S = { 
    "白レバ": 0.95, "赤レバ": 0.99, "虹レバ": 1.0, 
    "赤保留": 0.95, "緑保留": 0.20, "青保留": 0.05, "点滅保留": 0.01,
    "次回予告": 1.0, "金系": 0.80, "インフラ": 1.0 
};

window.onload = () => { initCharts(); updateUI(); };

function getDigitClass(num) {
    if (num === 7 && (mode === 'ST' || mode === '時短')) return 'digit gold';
    return (num % 2 !== 0) ? 'digit odd' : 'digit even';
}

function refillStock() {
    let maxHold = 4;
    if (mode !== '通常') maxHold = Math.min(4, rRem - (activeJob ? 1 : 0));
    while (reservedStock.length < maxHold) { reservedStock.push(createJob()); }
    updateHesoUI();
}

function createJob() {
    let prob = (mode !== '通常' ? SPECS.s : SPECS.n);
    let isHit = Math.random() < (1 / prob);
    let res = { isHit, heavy: false, name: [], trust: 0, vibe: false, vibeColor: "none", flash: false, text: "", holdType: "none", isSure: false };
    let r = Math.random() * 100;

    if (isHit) {
        res.heavy = true;
        if (mode === '通常' || mode === '時短') {
            if (r < 10) { res.name.push("次回予告"); res.text = "次回予告"; }
            else if (r < 20) { res.name.push("金系"); }
            else if (r < 45) { res.name.push("赤保留"); res.holdType = "red"; }
            else if (r < 80) { 
                let vr = Math.random() * 100; res.vibe = true;
                res.vibeColor = (vr < 60) ? "white" : (vr < 90 ? "red" : "rainbow");
                let vName = res.vibeColor === "white" ? "白レバ" : (res.vibeColor === "red" ? "赤レバ" : "虹レバ");
                res.name.push(vName); res.holdType = "vibe"; 
                if (res.vibeColor === "rainbow") res.isSure = true;
            }
            else if (r < 89) { res.name.push("レイ背景"); res.text = "レイ背景"; }
            else if (r < 90) { res.name.push("渚カヲル"); res.isSure = true; }
            else { res.name.push("弱演出"); res.heavy = false; }
        } else {
            if (r < 10) { res.name.push("次回予告"); res.text = "次回予告"; res.isSure = true; }
            else if (r < 43) { res.name.push("金系"); }
            else if (r < 64) { res.name.push("赤保留"); res.holdType = "red"; }
            else if (r < 90) { 
                let vr = Math.random() * 100; res.vibe = true;
                res.vibeColor = (vr < 60) ? "white" : (vr < 90 ? "red" : "rainbow");
                let vName = res.vibeColor === "white" ? "白レバ" : (res.vibeColor === "red" ? "赤レバ" : "虹レバ");
                res.name.push(vName); res.holdType = "vibe";
                if (res.vibeColor === "rainbow") res.isSure = true;
            }
            else if (r < 99) { res.flash = true; res.isSure = true; res.name.push("インフラ"); }
            else { res.name.push("弱演出"); res.heavy = false; }
        }
    } else {
        let hr = Math.random() * 100;
        let isN = (mode === '通常' || mode === '時短');
        let redGase = isN ? 0.05 : 0.01;
        let redVibeGase = isN ? 0.005 : 0.001; 
        let whiteVibeGase = isN ? 0.01 : 0.005; // 通常時 0.01%
        if (hr < redVibeGase) { res.name.push("赤レバ"); res.holdType = "vibe"; res.vibe = true; res.vibeColor = "red"; res.heavy = true; }
        else if (hr < (redVibeGase + whiteVibeGase)) { res.name.push("白レバ"); res.holdType = "vibe"; res.vibe = true; res.vibeColor = "white"; res.heavy = true; }
        else if (hr < (redVibeGase + whiteVibeGase + redGase)) { res.name.push("赤保留"); res.holdType = "red"; res.heavy = true; }
        else if (hr < (redVibeGase + whiteVibeGase + redGase + 0.1)) { res.name.push("緑保留"); res.holdType = "green"; }
        else if (hr < (redVibeGase + whiteVibeGase + redGase + 1.0)) { res.name.push("青保留"); res.holdType = "blue"; }
    }
    const map = (mode !== '通常') ? TRUST_MAP_S : TRUST_MAP_N;
    if (res.isSure) {
        res.trust = 100.00;
    } else if (res.name.length > 0) {
        let fail = 1; res.name.forEach(n => { if(map[n]) fail *= (1 - map[n]); });
        res.trust = (1 - fail) * 100;
    } else { 
        res.trust = (mode === '通常' ? (1/SPECS.n)*100 : (1/SPECS.s)*100); 
    }
    res.displayName = res.name.join("+") || "弱演出";
    return res;
}

async function startProcess() {
    if (!isAuto || isAnim) return;
    let hasHeavyInStock = reservedStock.some(job => job.heavy === true);
    if (mode !== '通常' && rRem <= 0 && reservedStock.length === 0 && !activeJob) {
        let prev = mode; 
        addLog(`【${prev}終了】 ${currentRushHits <= 1 ? (currentRushHits === 0 ? '0回' : '1回(' + prev + ')') : currentRushHits + '連'}`);
        mode = '通常'; currentRushHits = 0; updateUI();
        if (prev === '時短' && originalSpeedSetting === 'fast') autoSpeed = 'fast'; 
        else { isAuto = false; updateAutoBtns(); return; }
    }
    refillStock();
    if (reservedStock.length === 0 && !activeJob) { isAuto = false; updateAutoBtns(); return; }
    activeJob = reservedStock.shift(); refillStock(); updateUI();
    let eff = activeJob;
    if (optKokuchi && activeJob.isHit) { eff.flash = true; eff.isSure = true; eff.trust = 100; eff.displayName = "インフラ告知"; }
    totalRot++; currentRot++; lcdCount++; 
    if (mode !== '通常') { rRem--; totalBall -= 0.05; } else { totalBall -= (250 / 18); }
    updateCharts();

    // 履歴出力
    addLog(`${mode} ${lcdCount}回転【${eff.displayName}】信頼度:${eff.trust.toFixed(2)}%`);
    if (eff.vibe) document.getElementById('machine').classList.add('vibrate');
    if (eff.flash) document.getElementById('lamp').classList.add('lamp-active');
    if (eff.text) { const ov = document.getElementById('effect-overlay'); ov.innerText = eff.text; ov.style.display = 'block'; }

    // 【高速オート対応】アニメーション時間と更新間隔の調整
    let spinTime = (eff.heavy || hasHeavyInStock) ? 2000 : (autoSpeed === 'fast' ? 300 : 500);
    let intervalTime = (autoSpeed === 'fast') ? 20 : 40; // 高速時は20ms間隔で図柄更新

    let spin = setInterval(() => { 
        [1,2,3].forEach(i => { 
            let n = Math.floor(Math.random()*9)+1; 
            const el = document.getElementById('d'+i); 
            el.innerText = n; 
            el.className = getDigitClass(n); 
        }); 
    }, intervalTime);

    await new Promise(r => setTimeout(r, spinTime));
    clearInterval(spin);
    document.getElementById('machine').classList.remove('vibrate');
    document.getElementById('lamp').classList.remove('lamp-active');
    document.getElementById('effect-overlay').style.display = 'none';

    if (activeJob.isHit) {
        isAnim = true; hits++; 
        historyData.push(lcdCount); historyLabels.push(hits + "回目");
        if (mode === '通常' && currentRot > maxHamari) { maxHamari = currentRot; document.getElementById('max-hamari-box').innerText = `最大ハマリ: ${maxHamari}`; }
        currentRot = 0;
        let rand = Math.random() * 100, logDigit, isST = false, needsUpgrade = false, isZenkaiten = false;
        
        if (mode === '通常') {
            rushCount = 1; 
            if (rand < 3) { logDigit = 7; isST = true; totalBall += 1400; isZenkaiten = true; }
            else if (rand < 39) { logDigit = 3; isST = true; totalBall += 420; }
            else if (rand < 59) { logDigit = 2; isST = true; totalBall += 420; needsUpgrade = true; } 
            else { logDigit = 2; isST = false; totalBall += 420; }
        } else { 
            logDigit = 7; isST = true; totalBall += 1400; rushCount++; 
        }
        
        if (isZenkaiten) { 
            addLog(">> 全回転演出発生！！"); 
            document.getElementById('screen').classList.add('all-spin-bg');
            await new Promise(r => setTimeout(r, 2000));
            document.getElementById('screen').classList.remove('all-spin-bg');
        }
        [1,2,3].forEach(i => { const el = document.getElementById('d'+i); el.innerText = logDigit; el.className = getDigitClass(logDigit); });
        addLog(`>> 当たり！ 【${logDigit}】 ${lcdCount}回転`);
        await new Promise(r => setTimeout(r, 1200));
        if (needsUpgrade) {
            addLog(">> 昇格！ 奇数図柄へ変化");
            document.getElementById('lamp').classList.add('lamp-active');
            [1,2,3].forEach(i => { const el = document.getElementById('d'+i); el.innerText = 3; el.className = 'digit odd'; });
            await new Promise(r => setTimeout(r, 1000));
            document.getElementById('lamp').classList.remove('lamp-active');
        }
        if (isST) { mode = 'ST'; rRem = SPECS.st; } else { mode = '時短'; rRem = SPECS.jt; }
        currentRushHits++; lcdCount = 0; activeJob = null; refillStock(); updateUI(); 
        await new Promise(r => setTimeout(r, 800)); 
    } else { 
        [1,2,3].forEach(i => { const el = document.getElementById('d'+i); el.className = getDigitClass(parseInt(el.innerText)); });
        activeJob = null; 
        // 【高速オート対応】停止後のウェイトを短縮
        let waitAfterStop = (autoSpeed === 'fast') ? 100 : 1000;
        await new Promise(r => setTimeout(r, waitAfterStop)); 
    }
    isAnim = false; updateUI(); updateAutoBtns();
    if (isAuto) setTimeout(startProcess, (autoSpeed === 'fast' ? 10 : 200));
}

function toggleAuto(s) { if(isAuto && autoSpeed === s) { isAuto = false; } else { isAuto = true; autoSpeed = s; originalSpeedSetting = s; if(!isAnim) startProcess(); } updateAutoBtns(); }
function updateAutoBtns() { document.getElementById('btn-slow').classList.toggle('btn-stop', isAuto && autoSpeed === 'slow'); document.getElementById('btn-fast').classList.toggle('btn-stop', isAuto && autoSpeed === 'fast'); }
function toggleOpt(t) { if(t==='kokuchi') optKokuchi=!optKokuchi; document.getElementById('btn-'+t).classList.toggle('active'); }
function updateHesoUI() { const hA = document.getElementById('heso-area'); mode !== '通常' ? hA.classList.add('right-mode') : hA.classList.remove('right-mode'); for(let i=0; i<=4; i++) { const el = document.getElementById('h'+i); const s = (i===0) ? activeJob : (reservedStock[i-1] || null); el.className = `heso-ball ${i===0?'heso-current':''}`; if(s) { if(s.holdType === 'red') el.classList.add('heso-red'); else if(s.holdType === 'green') el.classList.add('heso-green'); else if(s.holdType === 'blue') el.classList.add('heso-blue'); else if(s.holdType === 'blink') el.classList.add('heso-blink'); else if(s.holdType === 'vibe') el.classList.add('heso-vibe'); else if(s.holdType === 'rainbow') el.classList.add('heso-rainbow'); else el.classList.add('heso-on'); } } }
function updateUI() { document.getElementById('hits').innerText = hits; document.getElementById('rush-count').innerText = rushCount; document.getElementById('current-rot').innerText = currentRot; document.getElementById('total-rot').innerText = totalRot; document.getElementById('balance').innerText = Math.floor(totalBall).toLocaleString(); document.getElementById('sub-display').innerText = mode==='通常' ? `通常:${lcdCount}` : `${mode}:${rRem}`; updateHesoUI(); }
function addLog(m) { const l = document.getElementById('log'); l.innerHTML = `> ${m}<br>${l.innerHTML}`; }
function initCharts() { sChart = new Chart(document.getElementById('slumpChart').getContext('2d'), { type: 'line', data: { labels: slumpLabels, datasets: [{ label: '差玉推移', data: slumpData, borderColor: '#8a2be2', borderWidth: 2, fill: false, pointRadius: 0 }] }, options: { responsive: true, maintainAspectRatio: false } }); hChart = new Chart(document.getElementById('historyChart').getContext('2d'), { type: 'bar', data: { labels: historyLabels, datasets: [{ label: '当り間回転数', data: historyData, backgroundColor: '#ff4444' }] }, options: { responsive: true, maintainAspectRatio: false } }); }
function updateCharts() { slumpData.push(totalBall); slumpLabels.push(totalRot.toString()); sChart.update('none'); hChart.update(); }
function openModal() { document.getElementById('modal-overlay').style.display='flex'; }
function closeModal() { document.getElementById('modal-overlay').style.display='none'; }
function resetData() { if(confirm('データをリセットしますか？')) location.reload(); }
</script>
</body>
</html>
